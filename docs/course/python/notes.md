# Python与人工智能 课程笔记


## Chap.3 程序流程控制

### 逻辑运算符短路求值

### 海伦公式
1 . 计算半周长

$$s = \frac{a + b + c}{2}$$

2 . 计算面积

$$A = \sqrt{s(s-a)(s-b)(s-c)}$$

### 布尔值
```
x = print(1,2,3)
print(x)
```
输出结果：
```
1 2 3
None
```
将输出函数赋值给变量x没有任何意义，但是依然执行输出。而x本身因为被赋值，就有数值，该数值为None。
### 选择结构
#### 三目条件表达式
语法格式：
```
value1 if 条件表达式 else value2
```
语法说明：
1. 三目是指value1、value2和条件表达式三个数据对象，三目必须写在同一行中。
2. 条件表达式为True时，返回结果为value1；为False时，返回value2。
3. 三目条件表达式中的value值可以是单一的数据值，也可以是一个表达式。

例如：
```
if x<y:
    print(x)
else:
    print(y)
```
使用三目表达式：
```
print(x if x<y else y)
或
print(x) if x<y else print(y)
```
注意：除了上述两种格式之外
```
small = x if x<y else y         # 正确写法
small = x if x<y else samll = y # 错误，赋值语句不能作为三目条件表达式的value
```

#### pass语句
pass表示一个空操作，通常在没有想好某一段程序功能时，先用pass占位置，这样可以在程序未写完代码功能的同时又能保证程序的逻辑完整性和语法正确性。是一个很好的调试语句。
例如：
```
if grade >= 60:
    pass  # 还没有想好成绩及格后的操作，先占位
else:
    print('不及格')
```

### 循环结构
#### range() 函数生成迭代序列
含数值型元素的可迭代对象可以直接使用求和函数：
```
# 求100以内的偶数和
print(sum(range(2,101,2)))
```
#### i 变化对循环的影响
for 循环执行的是对迭代器中数据对象的遍历此操作，循环体中用于绑定数据的变量值发生变化对for循环的下一次遍历是没有影响的。
```
for i in range(1,10,2):  #迭代器已经生成，i的值固定遍历1、3、5、7、9，不会改变
    print(i,end="")
    i=i+3                # 这句话对循环遍历没有任何影响
print(i)                 #唯一影响的是最后一次循环结束后，退出循环的变量值
```
输出结果是12

#### while循环求最大公约数和最小公倍数
```
# 求最小公倍数
a,b = eval(input("请输入两个整数a,b"))
if a>b:
    a,b = b,a # 提高算法效率，保证a大于b
gbs = a
while gbs%b != 0:
    gbs += a
print("%d和%d的最小公倍数为%d" % (a,b,gbs))

# 求最大公约数
gys = b
while a % gys != 0 or b % gys !=0:
    gys -= 1
print("%d和%d的最大公约数为%d" % (a,b,gys))
```
#### break语句
强行退出break语句所在的在内层循环

#### continue语句
当循环体执行到continue语句时，结束本次循环，即不再向下执行后续的循环体内容，并开始下一次循环。

continue语句不能放在循环体的最后一行，否则没有意义。

#### else子句
格式如下：
```
for 变量 in 迭代器:
    循环体
else:
    else子句代码块
```

**语法说明：**

1. else部分代码最多执行一次，属于退出循环前执行的最后一段代码
2. 当for循环遍历结束，或while循环条件表达式为False时执行else子句，即使for循环和while循环的循环体一次都不执行，也要执行else子句
3. else子句只有在循环体中遇到break语句强行退出循环时才不会被执行

**例题：** 输入一个大于1的正整数n，判断其是否为素数。

```
n = eval(input("请输入一个大于1的整数："))
k = int(pow(n,0.5)) # 能被整除的区间只需要从2到根号下n（包含）即可  
for i in range(2,k+1):
    if n % i == 0:
        print("%d不是素数" %n)
        break       # 不是素数强行退出整个循环
else:               # 进入else说明for循环全部结束，没有遇到break语句
    print("%d是素数" %n)  
```



## Chap.4 列表与元组
### 索隐于切片
步长为正时，切片内容与替换内容长度可以不等，甚至没有切到也可以以插入的方式修改列表内容

步长为负时，切片的的内容与替换内容的长度必须一致

例子：
```Python title="创建一个列表"
lst = [1,"hello",3,[4,5],'abc']
```

```Python title="1.切片长度与替换内容长度可以不等" linenums="1"
lst[2:4] = [7,8,9,10]
# 输出结果：
[1, 'hello', 7, 8, 9, 10, 'abc']
```

```Python title="2.没有切到直接在首位索引处加入" linenums="1"
lst[-2:-4] = [2,3] # 切片无效，倒过来切需要说明步长为-1才有效：lst[-2:-4:-1]
# 此时直接在索引为-2的位置之前插入
# 输出结果：
[1, 'hello', 7, 8, 9, 2, 3, 10, 'abc']
```

```Python title="3.步长为负。自右向左替换时长度必须一致" linenums="1"
lst[-5:-8:-1] = ["a","b","c"] # 切片无效，倒过来切需要说明步长为-1才有效：lst[-2:-4:-1]
# 此时直接在索引为-2的位置之前插入
# 输出结果：
[1, 'hello', 'c', 'b', 'a', 2, 3, 10, 'abc']
```

### 列表删除

```Python
del lst[0] # 删除列表索引号为0的元素
del lst # 删除整个列表
```

### 列表拼接

```Python
# "+"
b = a + [1,2]
# 在头部拼接
a[:0] = [1,2]
# 在尾部拼接
a[:len(a)] = [1,2]
# "*"重复拼接
a = [1,2] * 3
```

### 列表复制

一个数据对象同时赋值给两个变量，当列表中的元素发生变化时，其内存地址没有被修改，两个标签依然对应同一个内存地址，一个变量中的元素变化会同时应向另一个变量值。

```Python
lst1 = lst2 = [1,2,3]
lst1[1] = 4
# 此时lst1，lst2都变为[1,4,3] 
```

几种复制区别：

浅拷贝：若lst1中元素为不可变数据对象，当lst1发生元素增加或删除时，lst2不会被修改。
```Python
lst2 = lst1.copy() # 浅拷贝：内容相同，但内存地址不同
lst2 = lst1[:] # 与copy()效果相同
lst2 = lst1 # 同一内存地址
```


### 常用操作
#### 添加
1.```lst.extend()``` 

可以将各种对象扩充到列表对象中

```Python
lst = [1,2,3]
lst.extend((4,5,6))
# lst = [1,2,3,4,5,6]
lst.extend("ab")
# lst = [1,2,3,4,5,6,'a','b']
```

2.```lst.insert(index,x)```

在index处添加元素x，新元素在指定位置插入后，原序列将顺序右移。

```Python
lst = [1,2,3,4]
lst.insert(1,200) 
# lst = [1,200,2,3,4]
lst.insert(-1,30)
# lst = [1,200,2,3,30,4]
```

#### 删除

1.```lst.remove(x)```

删除首次出现的元素x，若没有指定元素怎会报错      

列表长度是动态变化的，用该方法容易出现错误。可采用切片的方式访问其浅复制对象，使访问和删除两个操作分开执行，做到删除不影响遍历操作

2.```lst.pop()```

删除索引对应元素并返回该值

```Python
lst = [1,2,3,4]
a = lst.pop(1) 
# lst = [1,3,4]
# a = 2
a = lst.pop() #默认删除最后一个元素
# lst = [1,3]
```

3.```lst.clear()```

清除列表中所有元素但保留内存地址

#### 排序

1.```lst.reverse()```

原地逆序，没有返回值

2.```lst.sort()```

原地排序，没有返回值

```Python
lst.sort(reverse = False, key = None)
```

reverse默认Flase（升序），True为降序

key用于指定排序规则，必须为一个函数

```Python
lst = [[3,5],[12,340],[34,5]]
lst.sort(key = max) #按元素中最大的值升序排序
lst.sort(key = sum) #按子列表中元素和排序
```

**注意：**

```print(lst.sort())```输出的值为None，因为lst.sort()没有返回值

3.```reserved()```和```sorted()```函数

**```reserved()```**

函数操作的配排序对象不会原地改变，函数会返回排序后新的对象

返回结果为生成器对象，不能显式显示，具有一次性取值的特点

```Python
lst = [1,2,3,4,5]
new_lst = reversed(lst)
# new_lst为生成器对象
print(list(new_lst))
# 输出为：[5,4,3,2,1]
```

**```sorted()```**

```Python
sorted(可迭代对象, reverse = Flase, key = None)
```

```Python
lst = [1,2,4,3,5]
new_lst = sorted(lst)
# new_lst = [1,2,3,4,5]
print(sorted(lst)) #也可直接输出
```

### 列表推导式

新列表 = [ 表达式 for 循环变量 in 迭代器]
 
```Python
lst = [5 for i in range(5)]
#lst = [5,5,5,5,5]
lst = [5*i for i in range(5)]
#lst = [0,5,10,15,20]
lst = [random.randint()]
```